from mpmath import *
import gmpy2
def invPow(x, n):
  high = 1
  while high ** n <= x :
    high *= 2
    low = high/2
    while low < high:
      mid = (low + high) / 2
      if low < mid and mid**n < x:
        low = mid
      elif high > mid and mid**n > x:
        high = mid
      else:
        return mid
    return mid + 1

def decryptSmallE(N, E, C) :
  # third argument makes the function super efficient
  # because it knows it is taking a mod inverse right after.
  return pow(C, E, N)

if __name__ == "__main__":
  mp.dps = 50
  mp.pretty = True
  N = 29331922499794985782735976045591164936683059380558950386560160105740343201513369939006307531165922708949619162698623675349030430859547825708994708321803705309459438099340427770580064400911431856656901982789948285309956111848686906152664473350940486507451771223435835260168971210087470894448460745593956840586530527915802541450092946574694809584880896601317519794442862977471129319781313161842056501715040555964011899589002863730868679527184420789010551475067862907739054966183120621407246398518098981106431219207697870293412176440482900183550467375190239898455201170831410460483829448603477361305838743852756938687673
  E = 3
  C = 2205316413931134031074603746928247799030155221252519872649604243394069216326314270624430181767863085854215545736160599718939066687544261205735290002239045830806570632200667142910415788763317978137702614731825117431700919216297401306846053 
  #print(decryptSmallE(N, E, C))
  #print("\n\n\n")
  #sol = nthroot(decryptSmallE(N, E, C), 3)
  d = pow(C, 1/3)
  # solved as picoCTF{n33d_a_lArg3r_e_1dcea0a2}
  #print(d)
  #s = nthroot(C, E)
  #print('%f' % s)
  #print('%f' % sol)


  #2,205,316,413,931,134,348,447,428,688,283,028,351,120,415,981,138,387,983,718,330,129,921,672,328,071,188,086,878,061,522,015,806,128,193,020,849,926,646,145,103,032,185,592,919,196,753,189,569,227,391,263,136,511,278,388,361,213,121,994,172,862,222,244,496,423,578,183,956,797,550,531,796,414,640,418,684,141,568,000
  ###
